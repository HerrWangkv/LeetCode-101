1. 判断奇数/偶数: num & 1
2. 取`num`二进制的某一位`(num >> i) & 1`，其中`i`指从低往高数第 `i` 位。
3. 如果x+5有可能超过int能表示的极限，可以用`min(x, INT_MAX-5) + 5`，类似地， 用`max(x, INT_MIN+5) - 5`表示x-5
4. 判断两链表相交位置(Intersection of Two Linked Lists)时，使用双指针法。两指针首先沿各自链表向前遍历，遍历完各自的链表后开始遍历另一个链表。由于链表a长度+链表b长度-公共长度固定，可找出相交位置。
5. 逆转链表(Reverse Linked List): 每次将原始头节点的下一个节点放到头，并顺次连接原始头节点和其下下个节点，直至原始头节点的下一个节点为空。
6. 链表和vector的一个很大区别是链表操作指针，故而可以用看起来并不inplace的方法实现inplace操作。
7. 针对长链表可以用快慢指针法快速确定中间位置(索引为`(n-1)//2`)
8.  for循环中，尤其range-based for loop(如`for(auto i : vec)`)中如果`vec`是一个函数的输出，且该输出在迭代过程中不变，应该先将其赋值给某一个变量。
9.  树的DFS遍历(递归方法更简单，容易理解，此处省略)
   1.  Pre-order Traversal: 对于每个根节点和其子树来说，先访问根节点，再访问左子树，最后访问右子树。
    - 递归
    ```cpp
    void preorder(TreeNode *root, vector<int> &ret) {
        if (!root)
            return;
        ret.push_back(root->val);
        preorder(root->left, ret);
        preorder(root->right, ret);
    }
    ```
    - 迭代
    ```cpp
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (node || !stk.empty()) {
            while (node) {
                ret.push_back(node->val);
                stk.push(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            node = node->right;
        }
        return ret;        
    }
    ```
    或者不使用node，先入栈根节点、右子树、左子树。

   2.  In-order Traversal: 对于每个根节点和其子树来说，先访问左子树，再访问根节点，最后访问右子树。
    - 递归
    ```cpp
    void inorder(TreeNode *root, vector<int> &ret) {
        if (!root) 
            return;
        inorder(root->left, ret);
        ret.push_back(root->val);
        inorder(root->right, ret);
    }
    ```
    - 迭代
    ```cpp
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> stk;
        TreeNode* node = root;
        while (node || !stk.empty()) {
            while (node) {
                stk.push(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            ret.push_back(node->val);
            node = node->right; //prevent from visiting the left subtree for the second time
        }
        return ret;        
    }
    ```
    如果node不存在右子树，则直接访问node的根节点
   
   3.  Post-order Traversal: 对于每个根节点和其子树来说，先访问左子树，再访问右子树，最后访问根节点。(适用于删除节点)
    - 递归
    ```cpp
    void postorder(TreeNode *root, vector<int> &ret) {
        if (!root)
            return;
        postorder(root->left, ret);
        postorder(root->right, ret);
        ret.push_back(root->val);
    }
    ```
    - 迭代
    ```cpp
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> stk;
        TreeNode *node = root, *prev = nullptr;
        while (node || !stk.empty()) {
            while (node) {
                stk.push(node);
                node = node->left;
            }
            node = stk.top();
            stk.pop();
            // If there is no right subtree or right subtree has been visited
            if (!node->right || node->right == prev) {
                ret.push_back(node->val);
                prev = node;
                node = nullptr;
            }
            else {
                stk.push(node); // Push root node again into stack
                node = node->right;
            }
        }
        return ret;
    }
    ```
    或者后序遍历可以由前序遍历反过来进行求解(1. 入栈时从左至右 2. vector反过来， 见N-ary Tree Postorder Traversal)

10. 在进行BFS时，如果想要把每层分开，则需要如下：
    ```cpp
    queue<Node*> q;
    q.push(root); //root为根节点
    while (!q.empty()) {
        int sz = q.size();//sz代表某一层的节点数
        for(int i = 0; i < sz; ++i) {
            Node *node = q.front();
            q.pop();
            /*
            相关操作
            */
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
    }
    ```
11. 如果要找其他点到某点集的最短距离(01 Matrix)，应该在第一步就将该点集所有点入队，然后BFS。
12. 如果想要计算某件事需要最少多少次操作才能实现，可以理解为强化学习中agent最少经过几步才能达到目标状态，可以使用BFS。见(Open the Lock), (Perfect Squares)。
13. 使用递归检测树是否是对称的，相当于将该树完全复制一下，然后一个从左，一个从右遍历。见(Symmetric Tree)
14. 按顺序寻找某节点所有祖先
    ```cpp
    bool inBranch(TreeNode *root, TreeNode *goal, vector<TreeNode*> &branch) {
        if (!root)
            return false;
        if (root == goal)
            return true;
        if (inBranch(root->left, goal, branch)) {
            branch.push_back(root->left);
            return true;
        }
        if (inBranch(root->right, goal, branch)) {
            branch.push_back(root->right);
            return true;
        }
        return false;
    }
    ```
    注意branch中所有祖先从下向上顺序排列，但不包含整棵树的根节点。该程序可被用于求解一般树中两个node的最低共同祖先
15. Balanced BST 指对每个节点，其左右节点的深度相差不大于1。而只要保证将一个sorted array的中间元素(索引为`n/2`)作为根节点，就能保证生成一个balanced BST。(Convert Sorted Array to Binary Search Tree)
16. 两种处理树的方法：
    1.  建立Node类，但该类仅包含数据成员(val, children等)和构造函数。所有处理该树的函数都在类外，并接受一个根节点root作为参数。
    2.  建立Tree类，该类包含数据成员(val, children等)和各种处理函数(如插入，搜索等)。向子树遍历时从this开始。(Implement Trie (Prefix Tree))
17. 我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将 base 取为一个质数(如769)。
18. 如果希望取长度为 n 的某数组中最大 k 个数(Top K Frequent Elements)，如果全部sort，则时间复杂度为$O(n\log n)$。而如果使用长度为 k 的优先队列， 则时间复杂度为$O(n\log k)$
19. 在处理vector左右移若干位时(Rotate Array)，多次翻转可能是一个好方法。
20. 滚动数组思想(Pascal's Triangle II)：本来必须用二维数组表示的量，如果第i+1个一维数组只取决于第i个一维数组，可以考虑仅使用一个一维数组来表示，并对该一维数组进行in-place操作。
21. 单调栈中常用于存储索引，并需要保证从栈底到栈顶各索引所代表的元素值大小呈单调关系。单调栈用来解决暂时无法解决的问题，但如果一旦能解决一个问题，可能可以顺便解决多个问题。栈为空表示问题都解决，栈中的索引表示未解决的问题。见(Daily Temperatures)
22. 对于字符串转数字，先乘10，再加新字符。注意处理负号。
23. 想要快速查找，使用哈希表。即把所有元素入map或入set。
24. 如binary search中一样需要取两个int平均值的情况下，使用`left + (right - left) / 2`，而不是`(left + right) / 2`，防止`left + right` 过大造成溢出。
25. 提到翻转，不仅要想到reverse函数，还要想到栈。
26. 3sum可以选择for + 双指针夹逼
27. 树状数组：

# 双指针
## 滑动窗口
1. 寻找最大窗口： left = -1， right= 0开局。移动right增大窗口到不能再增大(一个while循环)，移动left减小窗口到没必要减少(另一个while循环)，如此循环。见[3.longest substring without repeating characters](./submissions/3.longest-substring-without-repeating-characters.cpp)
## 夹逼
left = 0, right = n-1开局。
1. 避免重复：再找到满足条件的left, right对之后，不断增大left，减少right直到不重复(注意循环条件里要有left < right)。见[15.3 sum](submissions/15.3-sum.cpp)

# Baktracking
backtracking常用于组合问题，即求解所有可能的组合(不同顺序)或**单个元素可以无数次重复**的组合。可以用递归来解决backtracking问题，见[22.generate parentheses](./submissions/22.generate-parentheses.cpp), [46.permutations](submissions/46.permutations.cpp)：
1. helper函数往往返回类型为void
2. helper函数必须拥有一个参数表示截止到当前的组合
3. helper函数至少需要有一个变量来判断是否可以将这个组合加进ret里或如何改变组合

# 栈 & 队列
## 单调栈
- 单调栈中的“单调”指的是以栈中元素为索引的元素符合单调排列。
- 每个元素的索引都会入栈，但要保证单调性。
- 单调递增栈可以只用$O(n)$寻找vector中某个元素两侧最近的比该元素小的元素索引。见[84.largest rectangle in histogram](./submissions/84.largest-rectangle-in-histogram.cpp)

## 单调队列
- 单调队列中的“单调”指的是以栈中元素为索引的元素符合单调排列。
- 每个元素的索引都会入队，但要保证单调性。
- 单调队列可以用于查找一定范围窗口的最大值，见[239.sliding window maximum](submissions/239.sliding-window-maximum.cpp)

# 树
## Trie
Trie(又称prefix tree)各节点的值常为字符。根节点一般为空字符，每个节点的值都将其根节点的值作为前缀。如果仅考虑小写字母的话，对于每一个节点 / 树，我们仅需要一个boolean变量来表示该节点是否为叶节点(以避免某个前缀被当做完整单词)以及一个长度为26的vector表示子树。见[208.implement trie prefix tree](submissions/208.implement-trie-prefix-tree.cpp)

## 线段树 Segment Tree/ 树状数组 (Binary Indexed Tree)
给定数组vec, 利用二叉树(但实际上被实现成数组)来快速求解数组vec一段范围内元素的属性。二叉树的叶节点对应于原数组vec的每个值，所有非叶节点对应某一个范围，而该叶节点的值表示这一范围内的某种特性(和/最大值/最小值等)。

- 从原理上，从叶节点向上看：
  - 初始化$O(n)$：每个叶节点对应一个元素。非叶节点对应两个子节点范围的集合，其值可以是和/最大值/最小值等。
  - 更新$O(\log n)$： 先修改叶节点，再从下向上修改对应父节点。
  - 检索$O(\log n)$：从两个边界向中间夹逼，直至父节点相遇。原理是相遇节点能代表一棵完整二叉树，只需要额外计入边角料。即如果左边界是右节点或右边界是左节点，额外计入该边界所对应的值，再向右上/左上移动边界。
  
- 从实现上看，根节点在索引 1 。如果索引 i 不是一个叶节点，则其左右子节点分别在索引 2i 和 2i+1 处。第一个叶节点的索引是vec.size()。假设vec.size()=3，则索引3处的节点既是叶节点，也是根节点的右子节点。

- 应用场景：需要多次检索vec的某个范围属性。

- 基本功能实现：[307 Range Sum Query - Mutable](./submissions/307.range-sum-query-mutable.cpp)

### 变型
- 基本线段树中数组vec有时候是经过转化得到的。
- 线段树可能以全0 vector(如表示元素出现次数，这时注意使用[离散化](#离散化))初始化，再不断更新。注意线段树仅能同时处理一个范围，如果有多个范围(某索引之后、比当前值小)，则需要在一个范围中循环更新、查询。每次查询可以处理另一个范围。见[315.count of- maller numbers after self](submissions/315.count-of-smaller-numbers-after-self.cpp) 

## BST (Binary Search Tree)
Binary Search Tree(BST)是指对于所有节点来说，其左子树上的所有节点都小于该节点，其右子树上的所有节点都大于该节点。其中序遍历是升序的。BST常用于Search，小左大右。
- 在BST中插入一个节点(Insert into a Binary Search Tree)，使得插入后该树仍是一个BST：类似Search时将待添加节点的值与每个节点相比较，如果待添加的值较小，则移动到左子节点，反之移动到右子节点。如果移动后的节点为空，则在此处插入新节点。
- 从BST中删除一个节点(Delete Node in a BST)，使得删除后该树仍是一个BST：
    1.  如果该节点无子节点，直接删除。
    2.  如果该节点有一个子节点，用该子节点代替待删除节点。
    3.  如果该节点有两个子节点，用中序遍历的下一个节点代替待删除节点，注意此种情况下需要进行一次递归(当中序遍历的下一个节点为叶节点 / 有右子节点)
- 如果想要使用BST来快速查找第k大的数字(Kth Largest Element in a Stream)，则可以在每一个节点处记录该节点所有子孙节点的数字(包含该节点本身)，再每次从右子树开始遍历。
- BST中任意两个node的最低共同祖先满足最低祖先的值在两节点值之间。

# 动态规划
dp都可以表示什么：
1. `dp[i]`表示最后一个元素是索引i对应元素的所有组合中符合条件的最长长度，如[32.longest valid parentheses](submissions/32.longest-valid-parentheses.cpp)

2. `dp[i][j]`表示[i,j]范围是否符合条件，如[5.longest palindromic substring](submissions/5.longest-palindromic-substring.cpp)


# 图
有向图往往用一个二维数组和一个一维数组表示。
- 二维数组表示每个所有的边，每一行表示从行索引对应点出发的边的终点。
- 一维数组表示以该节点为终点的边的个数

见[207.course schedule](submissions/207.course-schedule.cpp)

# 堆
类似树状数组，堆也用数组来表示二叉树。只不过堆的根节点在0，且堆的父子节点之间没有明显的层次关系。使用堆排序(大根堆，用于升序排列)的步骤如下：
1. 将数组按BFS顺序入树(实际上无需操作，但需要认识到最后一个父节点的索引为 n//2-1，且每个父节点x的子节点索引分别为 2x+1 和 2x+2)
2. 从后往前保证所有父节点的值不小于其子节点的值(即大根堆)。此时可以保证根节点最大。
3. 从后往前将根节点与考虑范围内的最后一个元素交换，这样剩余元素中最大的就到了最后。之后逐渐缩小考虑范围

```cpp
void max_heapify(vector<int> &vec, int start, int end) {
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end) { 
        if (son + 1 <= end && vec[son] < vec[son + 1]) // 选择较大的子节点
            ++son;
        if (vec[dad] > vec[son]) // 如果父节点大于子节点，直接跳出函數
            return;
        else { // 否则交换父子内容，再比较子孙节点
            swap(vec[dad], vec[son]);
            //交换之后不能保证子节点的值(原父节点的值)大于孙节点的值，故需要继续下去
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(vector<int> &vec) {
    int len = vec.size();
    // 从最后一个子树开始交换最大值到父节点，保证父节点不比子节点小。结果就是父节点此时最大
    for (int i = len / 2 - 1; i >= 0; i--)
        max_heapify(vec, i, len - 1);
    // 依次将最大元素交换到最后，再缩小考虑范围。
    for (int i = len - 1; i > 0; i--) {
        swap(vec[0], vec[i]);
        max_heapify(vec, 0, i - 1);
    }
}
```
例题：[215.kth largest element in an array](submissions/215.kth-largest-element-in-an-array.cpp)

## 优先队列
`priority_queue`基于堆，默认最大值先出， 插入任意值 $O(\log n)$, 获得最大值 $O(1)$, 删除最大值 $O(\log n)$

# 奇技淫巧
## 离散化 (discretization)
有时候我们只注重元素出现的次数。如果元素是字符串等复杂数据结构，当然可以用map之类的，但如果元素是int类型的，则可以使用vector进行表述。但一个问题是所有独立元素不一定是连续的，甚至有可能极差很大，这时候就需要使用离散化。

- 原理：
  - 去重(assign, sort, unique, erase四件套)，得到unique升序vector
  -  对每个元素取其在去重后vector的索引为次数vector的索引。(lower_bound)

# 数学
## 字典序下一个排列
字典序(除纯降序外)的本质是从左侧选取一个较小数，将其与右侧一个比该较小数稍微大一点的数进行互换。互换之后将右侧的降序数列再翻转。

例如将 nums = [1, 1, 3, 2, 2] 变 [1, 2, 1, 2, 3]：
1. 从后往前找到第一个比其后续元素小的元素，设其索引为i(如果纯降序，i设为-1), 此处i = 1， nums[i] = 1
2. 如果存在i(即nums不是纯降序)：
   1. 再次从后向前扫描，找到第一个比索引i处的元素大的元素，设其索引为j，此处j = 4, nusm[j] = 2
   2. swap(nums[i], nums[j]); nums变成[1, 2, 3, 2, 1]
3. reverse(nums.begin() + i + 1, nums.end()); nums变成[1, 2, 1, 2, 3]

## 快慢指针法
- 基础写法(找中点)：
    ```cpp
    if (!head)
        return nullptr;
    ListNode *fast = head, *slow = head;
    while (fast->next && fast->next->next) {
        fast = fast->next->next;
        slow = slow->next;
        ...
    }
    ```
- fast到某一点(tail,tail可以是nullptr)结束写法
    ```cpp
    if (!head)
        return nullptr;
    ListNode *fast = head, *slow = head;
    while (fast != tail) {
        slow = slow->next;
        fast = fast->next;
        if (fast != tail)
            fast = fast->next;
    }
    ```
  
1. 判断链表是够含有环状结构，使用快慢指针法：fast、slow两个指针分别以2、1的速度前进。首次重合后fast置回head， 然后fast、slow均以1的速度前进。再次重合处即是环开始的地方。数学解释见[142 Linked List Cycle II](03_玩转双指针.md#142-Linked%20List%20Cycle%20II)，代码实现见[142 Linked List Cycle II](submissions/142.linked-list-cycle-ii.cpp)

2. 快慢指针可以找到无环链表的中点，如[148.sort list](submissions/148.sort-list.cpp)


如何插入和删除一个堆中的节点